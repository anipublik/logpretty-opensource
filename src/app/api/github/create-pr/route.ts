import { NextRequest, NextResponse } from 'next/server'
import { getSession } from '@/lib/auth/session'
import { Octokit } from '@octokit/rest'
import { transformLog } from '@/lib/ai/anthropic'

interface TransformRequest {
  owner: string
  repo: string
  files: Array<{
    path: string
    sha: string
    language: string
  }>
}

export async function POST(req: NextRequest) {
  const session = await getSession()

  if (!session) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 }
    )
  }

  try {
    const { owner, repo, files } = await req.json() as TransformRequest

    if (!owner || !repo || !files || files.length === 0) {
      return NextResponse.json(
        { error: 'Owner, repo, and files are required' },
        { status: 400 }
      )
    }

    const octokit = new Octokit({ auth: session.githubToken })

    // Get the default branch
    const { data: repoData } = await octokit.repos.get({ owner, repo })
    const defaultBranch = repoData.default_branch

    // Get the latest commit SHA from the default branch
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`,
    })
    const latestCommitSha = refData.object.sha

    // Create a new branch
    const branchName = `logpretty-transform-${Date.now()}`
    await octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: latestCommitSha,
    })

    // Transform and update each file
    const transformedFiles: Array<{ path: string; success: boolean }> = []
    
    for (const file of files) {
      try {
        // Get the file content
        const { data: blob } = await octokit.git.getBlob({
          owner,
          repo,
          file_sha: file.sha,
        })

        const originalContent = Buffer.from(blob.content, 'base64').toString('utf-8')

        // Transform the content using AI
        const transformed = await transformLog(originalContent, file.language)

        // Update the file in the new branch
        await octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: file.path,
          message: `Transform logging in ${file.path} to structured JSON`,
          content: Buffer.from(transformed.code).toString('base64'),
          branch: branchName,
          sha: file.sha,
        })

        transformedFiles.push({ path: file.path, success: true })
      } catch (error) {
        console.error(`Error transforming ${file.path}:`, error)
        transformedFiles.push({ path: file.path, success: false })
      }
    }

    // Create a pull request
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: 'ðŸ”¥ Transform logging to structured JSON',
      head: branchName,
      base: defaultBranch,
      body: `## LogPretty Transformation

This PR transforms legacy logging statements to modern structured JSON logging.

### Files Transformed
${transformedFiles.map(f => `- ${f.success ? 'âœ…' : 'âŒ'} \`${f.path}\``).join('\n')}

### Changes Include
- Structured key-value logging
- Proper log levels (debug/info/warn/error)
- Correlation/trace IDs where relevant
- Best practices for production logging

Generated by [LogPretty](https://github.com/anipublik/logpretty) ðŸ”¥`,
    })

    return NextResponse.json({
      success: true,
      prUrl: pr.html_url,
      prNumber: pr.number,
      branch: branchName,
      filesTransformed: transformedFiles.filter(f => f.success).length,
      filesTotal: files.length,
    })
  } catch (error) {
    console.error('PR creation error:', error)
    return NextResponse.json(
      { error: 'Failed to create pull request' },
      { status: 500 }
    )
  }
}
